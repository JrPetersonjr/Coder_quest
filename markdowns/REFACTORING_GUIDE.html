<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>REFACTORING_GUIDE</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: #0a0e27;
            color: #00ff41;
        }
        h1, h2, h3, h4, h5, h6 {
            color: #00ffff;
            border-bottom: 1px solid #00ffff33;
            padding-bottom: 0.3em;
        }
        code {
            background: #1a1e3a;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #ff00ff;
        }
        pre {
            background: #1a1e3a;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border-left: 3px solid #00ffff;
        }
        pre code {
            background: none;
            padding: 0;
            color: #00ff41;
        }
        a {
            color: #00ffff;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        blockquote {
            border-left: 4px solid #00ffff;
            padding-left: 20px;
            margin-left: 0;
            color: #00ffff99;
        }
        ul, ol {
            padding-left: 30px;
        }
        li {
            margin-bottom: 0.5em;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #00ffff33;
            padding: 10px;
            text-align: left;
        }
        th {
            background: #1a1e3a;
            color: #00ffff;
        }
        hr {
            border: none;
            border-top: 1px solid #00ffff33;
            margin: 30px 0;
        }
    </style>
</head>
<body>
    <pre># &#127918; TECHNOMANCER REFACTORING GUIDE
## From Monolithic to Modular Architecture

---

## **What We Just Did**

We split your game into **three layers**:

### **Layer 1: GameEngine.js** (Pure Logic)
- ✅ No DOM access
- ✅ No jQuery, no document.getElementById()
- ✅ Pure data + methods
- ✅ **Portable to ANY platform**

**What it does:**
- Manages `gameState`
- Parses commands (`handleCommand()`)
- Executes game logic (battles, definitions, zone changes)
- Calls callbacks instead of manipulating DOM directly

**Key pattern:**
```javascript
// Instead of this (DOM-coupled):
function appendLine(text) {
  document.getElementById(&quot;output&quot;).appendChild(div);
}

// We do this (UI-agnostic):
this.output(text, type) {
  this.onOutput({ text, type });  // Callback - UI handles rendering
}
```

---

### **Layer 2: GameUI.js** (Presentation)
- Manages DOM elements
- Listens to engine callbacks
- Updates the screen when engine fires events
- Can be **completely replaced** with React/Vue/Godot UI

**What it does:**
- Connects input fields to `engine.handleCommand()`
- Renders engine output to the DOM
- Updates stats panel when state changes

**Key pattern:**
```javascript
// Engine fires callback:
engine.onOutput = (output) =&gt; this.handleEngineOutput(output);

// UI responds by rendering:
handleEngineOutput(output) {
  const div = document.createElement(&quot;div&quot;);
  div.textContent = output.text;
  this.outputElement.appendChild(div);
}
```

---

### **Layer 3: index.html** (Entry Point)
- Creates engine instance
- Creates UI instance
- They talk to each other, not the world

```javascript
gameEngine = new GameEngine();
gameUI = new GameUI(gameEngine);
// Done! They&#39;re wired up and talking
```

---

## **Why This Matters**

### **Before (Tightly Coupled):**
```
index.html
  ↓
core.js (has DOM refs)
  ↓
game.js (has DOM refs)
  ↓
encounters.js (needs to call appendLine())
  ↓
&#128683; Can&#39;t port to Godot without rewriting everything
```

### **After (Loosely Coupled):**
```
GameEngine.js (pure logic)
  ↑ ↓
  ↓ callback
GameUI.js (DOM binding)
  ↑ ↓
  ↓ callback
index.html (glue)

✅ Port GameEngine to Godot? Just write new UI layer!
```

---

## **How to Test It Works**

1. **Open the game** - it should load and work exactly like before
2. **Type commands** - `help`, `stats`, `go hub`, `define foo bar`
3. **Check the console** - you&#39;ll see `[GameEngine] Initialized` and `[GameUI] Initialized`

**If something breaks:**
- Check browser console for errors
- The old code is still there as fallback
- We&#39;re running BOTH systems in parallel right now

---

## **Next Steps: Gradual Migration**

We DON&#39;T need to migrate everything at once. Here&#39;s the plan:

### **Phase 1: ✅ Done**
- `GameEngine` base class
- `GameUI` adapter
- Hybrid system running

### **Phase 2: Move Core Systems (1-2 days)**
Migrate these into GameEngine:
- Combat system (`attack()`, `endBattle()`)
- Encounter logic
- Spell system
- Terminal hacking

**Pattern:**
```javascript
// OLD (in core.js, tightly coupled):
function attack() {
  appendLine(&quot;You attack!&quot;);  // Direct DOM
  enemy.hp -= dmg;
}

// NEW (in GameEngine):
attack() {
  this.output(&quot;You attack!&quot;);  // Via callback
  this.gameState.currentEnemy.hp -= dmg;
}
```

### **Phase 3: Refactor Data Systems (1-2 days)**
Move into GameEngine:
- Zone data
- Enemy data  
- Puzzle data
- Spell definitions

**Pattern:**
```javascript
// Make them methods, not global objects:
getZoneData(zoneId) { return ZONE_DATA[zoneId]; }
getEnemyData(enemyId) { return ENEMY_DATA[enemyId]; }
```

### **Phase 4: Optional - Integrate Existing Systems**
Gradually fold in:
- DiceSystem
- SpellCrafting
- AncientTerminal
- FXSystem

---

## **Code Example: Migrating a Command**

### **Original (core.js):**
```javascript
function cmdDefine(args) {
  if (args.length &lt; 2) {
    appendLine(&quot;Usage: define &lt;name&gt; &lt;value&gt;&quot;, &quot;error&quot;);
    return;
  }
  const name = args[0].toLowerCase();
  const value = args.slice(1).join(&quot; &quot;);
  gameState.defined[name] = value;
  appendLine(`Defined: ${name} = ${value}`, &quot;highlight&quot;);
  gameState.exp += 5;
  FXSystem.playSound(&quot;confirm&quot;);
  updateUI();
}
```

### **Migrated (GameEngine):**
```javascript
cmdDefine(args) {
  if (args.length &lt; 2) {
    this.output(&quot;Usage: define &lt;name&gt; &lt;value&gt;&quot;, &quot;error&quot;);
    return;
  }
  const name = args[0].toLowerCase();
  const value = args.slice(1).join(&quot; &quot;);
  
  // Pure logic - no side effects
  this.gameState.defined[name] = value;
  this.output(`Defined: ${name} = ${value}`, &quot;highlight&quot;);
  this.gameState.exp += 5;
  
  // Trigger callbacks
  this.onStateChange(this.gameState);
  // this.playSound(&quot;confirm&quot;); // Add this later as callback
}
```

**UI layer handles the rest:**
```javascript
// In GameUI.js - called when state changes
handleStateChange(state) {
  this.updateStats();
  // FXSystem.playSound(&quot;confirm&quot;); // Optional
}
```

---

## **Benefits You Get**

1. **Platform Independence**
   - Can run in browser ✅
   - Can run in Godot with Godot UI layer
   - Can run in Roblox with Lua wrapper
   - Can run in Node.js server for multiplayer

2. **Testability**
   - Engine logic can be unit tested
   - No need to mock the DOM
   - Pure functions = predictable behavior

3. **Maintainability**
   - Bug in rendering? Fix GameUI.js
   - Bug in logic? Fix GameEngine.js
   - They don&#39;t affect each other

4. **Reusability**
   - GameEngine can be included in multiple UIs
   - Web version + React version + Godot version all use same engine

---

## **Common Questions**

**Q: Do I have to refactor everything at once?**
A: No! Keep old code running. Migrate gradually. Both systems coexist.

**Q: What about FXSystem and other systems?**
A: Wrap them as optional callbacks:
```javascript
this.onPlaySound = options.onPlaySound || (() =&gt; {});
// Then in commands:
this.onPlaySound(&quot;confirm&quot;);
```

**Q: How do I test this locally?**
A: Open `index.html` in browser. Game should work. Check console for init messages.

**Q: When should I delete the old code?**
A: Never delete until ALL functionality is migrated and tested. 

**Q: Can I run old + new systems together?**
A: Yes! Right now your old code still works. GameEngine is supplementary.

---

## **File Structure (After Migration)**

```
Quest_For_The_Code_LIVE/
├── index.html              (Entry point)
├── GameEngine.js           (Pure logic - PORTABLE)
├── GameUI.js               (DOM binding - PLATFORM SPECIFIC)
├── game-data.js            (All static data)
│
├── [OLD - Can be refactored gradually]
├── core.js
├── game.js
├── encounters.js
├── etc...
│
├── [OPTIONAL - External systems]
├── dice.js                 (DiceSystem)
├── fx.js                   (FXSystem)
├── spells-data.js          (Spell registry)
└── ...
```

---

## **Next Actions**

1. **Test it**: Open the game, confirm it works
2. **Identify next command to migrate**: Pick one (`cmdBattle`, `cmdCast`, etc.)
3. **Move it**: Add method to GameEngine, update GameUI callbacks
4. **Verify**: Test in browser, make sure no regression
5. **Repeat**: One command at a time

---

## **You Now Have:**

✅ A pure game engine (portable to ANY platform)
✅ A UI adapter layer (easily swappable)
✅ A clear migration path (incremental, not disruptive)
✅ The ability to test game logic without a browser
✅ A foundation for Godot/Roblox/multiplayer

**Your game is now architecture-ready for the future. &#128640;**
    </pre>
</body>
</html>
