<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ARCHITECTURE_DIAGRAMS</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: #0a0e27;
            color: #00ff41;
        }
        h1, h2, h3, h4, h5, h6 {
            color: #00ffff;
            border-bottom: 1px solid #00ffff33;
            padding-bottom: 0.3em;
        }
        code {
            background: #1a1e3a;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #ff00ff;
        }
        pre {
            background: #1a1e3a;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border-left: 3px solid #00ffff;
        }
        pre code {
            background: none;
            padding: 0;
            color: #00ff41;
        }
        a {
            color: #00ffff;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        blockquote {
            border-left: 4px solid #00ffff;
            padding-left: 20px;
            margin-left: 0;
            color: #00ffff99;
        }
        ul, ol {
            padding-left: 30px;
        }
        li {
            margin-bottom: 0.5em;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #00ffff33;
            padding: 10px;
            text-align: left;
        }
        th {
            background: #1a1e3a;
            color: #00ffff;
        }
        hr {
            border: none;
            border-top: 1px solid #00ffff33;
            margin: 30px 0;
        }
    </style>
</head>
<body>
    <pre># &#128260; ARCHITECTURE FLOW DIAGRAMS

Visual guides to understand how the three layers work together.

---

## **1. Command Flow Diagram**

```
USER INPUT
    ↓
    └─ Types: &quot;battle syntax-imp&quot;
    ↓
HTML INPUT ELEMENT
    ↓
    └─ User presses Enter key
    ↓
GameUI.handleSend()
    ├─ Get input: &quot;battle syntax-imp&quot;
    ├─ Clear input field
    ├─ Call: engine.handleCommand(&quot;battle syntax-imp&quot;)
    ↓
GameEngine.handleCommand()
    ├─ Parse: cmd = &quot;battle&quot;, args = [&quot;syntax-imp&quot;]
    ├─ Check game state
    ├─ Call: this.cmdBattle([&quot;syntax-imp&quot;])
    ↓
GameEngine.cmdBattle()
    ├─ Validate arguments
    ├─ Get enemy data
    ├─ Update this.gameState
    ├─ Call: this.output(&quot;⚔ A Syntax Imp appears!&quot;, &quot;battle&quot;)
    ↓
GameEngine.output() [CALLBACK 1]
    ├─ Package data: {text, type, timestamp}
    ├─ Call: this.onOutput({...})
    ↓
GameUI.handleEngineOutput()
    ├─ Create &lt;div&gt; element
    ├─ Add CSS class
    ├─ Set text content
    ├─ Append to #output
    ↓
RENDERED TEXT
    └─ User sees: &quot;⚔ A Syntax Imp appears!&quot; in green text
```

---

## **2. State Change Notification**

```
Game Logic Changes State
    ↓
    └─ Example: gameState.hp = 45 (took damage)
    ↓
Engine calls: this.onStateChange(this.gameState)
    ↓
GameUI.handleStateChange()
    ├─ Call: this.updateStats()
    ├─ Call: this.updateRoom()
    ├─ Call: this.updateDefinitions()
    ↓
HTML Display Updates
    ├─ Stats div shows new HP
    ├─ Room name updates
    ├─ Definitions list updates
    ↓
USER SEES UPDATED DISPLAY
```

---

## **3. Architecture Layers**

```
┌─────────────────────────────────────────────────────────────┐
│                        BROWSER DOM                           │
│  - HTML elements: &lt;div id=&quot;output&quot;&gt;, &lt;input id=&quot;input&quot;&gt;    │
│  - CSS styling: .line, .battle, etc                         │
│  - Event listeners: click, keydown                           │
└────────────────┬────────────────────────────────────────────┘
                 │
         ┌───────▼─────────┐
         │                 │
┌────────┴─────────────────▼────────┐
│         GAMEUI.JS (UI LAYER)       │
│                                    │
│ - Manages DOM elements             │
│ - Listens to engine callbacks      │
│ - Renders output                   │
│ - Updates display                  │
│ - Handles user input               │
│                                    │
│ Methods:                           │
│ • handleSend()                     │
│ • handleEngineOutput()             │
│ • handleStateChange()              │
│ • updateStats()                    │
│ • updateDefinitions()              │
└────────────────┬────────────────────┘
                 │
         ┌───────▼─────────┐
         │ Callbacks       │
         │ onOutput()      │
         │ onStateChange() │
         └───────┬─────────┘
                 │
┌────────────────▼────────────────────┐
│     GAMEENGINE.JS (LOGIC LAYER)     │
│                                     │
│ - Manages game state                │
│ - Parses commands                   │
│ - Executes logic                    │
│ - NO DOM ACCESS                     │
│ - NO UI DEPENDENCIES                │
│                                     │
│ Properties:                         │
│ • gameState = {...}                 │
│ • onOutput (callback)               │
│ • onStateChange (callback)          │
│                                     │
│ Methods:                            │
│ • handleCommand(input)              │
│ • cmdBattle(args)                   │
│ • cmdDefine(args)                   │
│ • attack()                          │
│ • output(text, type)                │
│ • getEnemyData(enemyId)             │
│ • getZoneData(zoneId)               │
└────────────────────────────────────┘
```

---

## **4. Data Flow: What Gets Passed**

### **User Input → Engine**
```
GameUI.input.value = &quot;define foo bar&quot;
    ↓
GameUI.handleSend()
    ↓
engine.handleCommand(&quot;define foo bar&quot;)
    ↓ (string is passed)
GameEngine receives: &quot;define foo bar&quot;
```

### **Engine Output → UI**
```
GameEngine.output(&quot;Defined: foo = bar&quot;, &quot;highlight&quot;)
    ↓
this.onOutput() callback
    ↓ (object is passed)
{
  text: &quot;Defined: foo = bar&quot;,
  type: &quot;highlight&quot;,
  timestamp: 1705...
}
    ↓
GameUI.handleEngineOutput()
    ↓
Renders to DOM
```

### **State Change Notification**
```
GameEngine updates: this.gameState.hp = 45
    ↓
this.onStateChange() callback
    ↓ (entire state object is passed)
{
  zone: &quot;hub&quot;,
  hp: 45,
  maxHp: 50,
  level: 1,
  exp: 25,
  ...
}
    ↓
GameUI.handleStateChange()
    ↓
Extracts only what it needs
    ↓
Updates display
```

---

## **5. Command Execution Sequence**

```
STEP 1: User Types
┌──────────────────┐
│ help             │
│ battle syntax-imp│  ← User types a command
│ define foo bar   │
└──────────────────┘

STEP 2: UI Captures Input
┌────────────────────────────┐
│ &lt;input&gt; fires &#39;Enter&#39; key  │
│ GameUI.handleSend() called │
└────────────────────────────┘

STEP 3: Input Goes to Engine
┌────────────────────────────────┐
│ engine.handleCommand(rawInput) │
│   - Trims whitespace           │
│   - Echoes to output           │
│   - Parses command &amp; args      │
│   - Routes to handler          │
└────────────────────────────────┘

STEP 4: Command Executes
┌──────────────────────────────┐
│ switch(cmd) {               │
│   case &quot;battle&quot;:            │
│     → cmdBattle(args)       │
│   case &quot;define&quot;:            │
│     → cmdDefine(args)       │
│ }                            │
└──────────────────────────────┘

STEP 5: Logic Executes
┌────────────────────────────────┐
│ GameEngine.cmdBattle() {       │
│   - Validate input             │
│   - Get enemy data             │
│   - Update gameState           │
│   - output(&quot;⚔ Enemy appears&quot;)  │
│ }                              │
└────────────────────────────────┘

STEP 6: Output Callback Fires
┌──────────────────────────────┐
│ onOutput({                   │
│   text: &quot;⚔ Enemy appears&quot;,  │
│   type: &quot;battle&quot;             │
│ })                           │
└──────────────────────────────┘

STEP 7: UI Renders
┌─────────────────────────┐
│ &lt;div class=&quot;line battle&quot;&gt;│
│   ⚔ Enemy appears       │
│ &lt;/div&gt;                  │
│                         │
│ Appended to #output     │
└─────────────────────────┘

STEP 8: User Sees Result
┌──────────────────────────────┐
│ [Green text on black screen] │
│                              │
│ &gt; battle                     │
│ ⚔ Enemy appears             │
│ HP: 15                       │
│ Commands: attack, run, stats │
│                              │
│ &gt;_                           │
└──────────────────────────────┘
```

---

## **6. Battle System Flow (Real Example)**

```
User: &quot;battle syntax-imp&quot;
    ↓
Engine: cmdBattle() starts
    ├─ Check: !inBattle? ✓
    ├─ Get enemy: getEnemyData(&quot;syntax-imp&quot;)
    ├─ Clone enemy data (so we don&#39;t modify original)
    ├─ Set: gameState.inBattle = true
    ├─ Set: gameState.currentEnemy = {...cloned enemy...}
    ├─ Output: &quot;⚔ A Syntax Imp appears!&quot;
    └─ Output: &quot;HP: 15&quot;
    ↓
User: &quot;attack&quot;
    ↓
Engine: handleCommand() sees inBattle=true
    ├─ Routes to: handleBattleCommand(&quot;attack&quot;)
    └─ (NOT normal command routing!)
    ↓
Engine: attack()
    ├─ Get current enemy
    ├─ Calculate damage: 1d6 + level
    ├─ Reduce enemy HP
    ├─ Output: &quot;You attack for 8 damage!&quot;
    ├─ Check: enemy.hp &lt;= 0? No...
    └─ Schedule: enemyTurn() after 500ms
    ↓
Engine: enemyTurn() [500ms later]
    ├─ Enemy attacks player
    ├─ Calculate damage: 1d5 + attack
    ├─ Reduce player HP
    ├─ Output: &quot;Syntax Imp attacks for 3 damage!&quot;
    ├─ Check: player.hp &lt;= 0? No...
    └─ Wait for next player input
    ↓
User: &quot;attack&quot;
    ↓
Engine: attack()
    ├─ Calculate damage: 1d6 + level
    ├─ Reduce enemy HP
    ├─ Output: &quot;You attack for 7 damage!&quot;
    ├─ Check: enemy.hp &lt;= 0? YES!
    ├─ Call: endBattle(true)
    │   ├─ Set: inBattle = false
    │   ├─ Set: currentEnemy = null
    │   ├─ Add exp: gameState.exp += 10
    │   ├─ Output: &quot;Defeated Syntax Imp!&quot;
    │   ├─ Output: &quot;Gained 10 EXP!&quot;
    │   └─ Fire: onStateChange()
    └─ Back to normal command mode
    ↓
User: &quot;stats&quot;
    ↓
Engine: handleCommand() sees inBattle=false
    ├─ Routes to: cmdStats()
    ├─ Output: &quot;HP: 47/50&quot;
    ├─ Output: &quot;EXP: 35/100&quot;
    └─ Command runs normally
```

---

## **7. How Callbacks Keep Things Decoupled**

### **Without Callbacks (Tight Coupling) ❌**
```javascript
GameEngine (engine.js):
function attack() {
  enemy.hp -= dmg;
  FXSystem.playSound(&quot;attack&quot;);  // ← Engine knows about FX system!
  updateUI();                     // ← Engine knows about UI!
  document.getElementById(...);   // ← Engine knows about DOM!
}

Problem: Can&#39;t use engine anywhere except web browser!
```

### **With Callbacks (Loose Coupling) ✅**
```javascript
GameEngine:
constructor(options) {
  this.onPlaySound = options.onPlaySound || (() =&gt; {});
}

attack() {
  enemy.hp -= dmg;
  this.onPlaySound(&quot;attack&quot;);  // ← Notify whoever is listening
}

// Browser uses it:
const engine = new GameEngine({
  onPlaySound: (sound) =&gt; FXSystem.playSound(sound)
});

// Server uses it:
const engine = new GameEngine({
  onPlaySound: (sound) =&gt; broadcast({event: &quot;sound&quot;, type: sound})
});

// CLI uses it:
const engine = new GameEngine({
  onPlaySound: () =&gt; {}  // Do nothing
});

Same engine, different behavior, no coupling!
```

---

## **8. State Update Cycle**

```
Initial State:
{
  hp: 50,
  inBattle: false,
  ...
}

User Action:
&quot;battle syntax-imp&quot;
    ↓
State Changes:
{
  hp: 50,
  inBattle: true,  ← Changed!
  currentEnemy: {...}  ← Changed!
  ...
}
    ↓
Engine fires: onStateChange(newState)
    ↓
UI responds: handleStateChange(newState)
    ├─ updateStats()
    ├─ updateDisplay()
    ├─ updateDefinitions()
    ↓
HTML Updates:
- Stats div refreshes
- Buttons might appear/disappear
- Display reflects new state
```

---

## **9. Error Handling Flow**

```
Invalid Input: &quot;battle nonexistent-enemy&quot;
    ↓
GameEngine.cmdBattle():
    ├─ getEnemyData(&quot;nonexistent-enemy&quot;)
    ├─ Returns: null
    ├─ Check: if (!enemy)
    ├─ Output: &quot;Enemy &#39;nonexistent-enemy&#39; not found.&quot;, &quot;error&quot;
    └─ Return (exit function)
    ↓
OnOutput callback:
    ├─ {text: &quot;Enemy not found...&quot;, type: &quot;error&quot;}
    ↓
GameUI.handleEngineOutput():
    ├─ Create: &lt;div class=&quot;line error&quot;&gt;
    ├─ Content: &quot;Enemy &#39;nonexistent-enemy&#39; not found.&quot;
    ├─ CSS applies red color (#ff6e6e)
    ↓
User sees: Red error message
Game state: Unchanged (no battle started)
```

---

## **Quick Reference**

### **What Goes Where**

| What | Where | Example |
|------|-------|---------|
| Game state | `GameEngine.gameState` | `{hp: 50, inBattle: false}` |
| Game logic | `GameEngine.cmdXXX()` | `cmdBattle()`, `attack()` |
| DOM refs | `GameUI` only | `document.getElementById()` |
| Callbacks | `GameEngine.onXXX` | `onOutput`, `onStateChange` |
| Rendering | `GameUI` only | Creating divs, styling |
| Input parsing | `GameEngine` | `handleCommand()` |
| Event listeners | `GameUI` | Click, keydown handlers |

### **When Something Changes**

1. **User action** → UI catches it
2. **Command sent** → Engine processes it
3. **State changes** → Engine triggers callback
4. **UI responds** → Display updates
5. **User sees** → Result on screen

### **To Add a New Feature**

1. Add logic to `GameEngine.cmdNewFeature()`
2. Call `this.output()` when needed
3. Call `this.onStateChange()` when state changes
4. `GameUI` automatically responds to callbacks
5. Done!

---

You now have a complete mental model of how the system works! &#127918;
    </pre>
</body>
</html>
